{
  "version": 3,
  "sources": ["../../../node_modules/@orama/wc-components/node_modules/.pnpm/@stencil+store@2.0.16_@stencil+core@4.19.0/node_modules/@stencil/store/dist/index.mjs"],
  "sourcesContent": ["import { getRenderingRef, forceUpdate } from '@stencil/core';\n\nconst appendToMap = (map, propName, value) => {\n    const items = map.get(propName);\n    if (!items) {\n        map.set(propName, [value]);\n    }\n    else if (!items.includes(value)) {\n        items.push(value);\n    }\n};\nconst debounce = (fn, ms) => {\n    let timeoutId;\n    return (...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            fn(...args);\n        }, ms);\n    };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce((map) => {\n    for (let key of map.keys()) {\n        map.set(key, map.get(key).filter(isConnected));\n    }\n}, 2000);\nconst stencilSubscription = () => {\n    if (typeof getRenderingRef !== 'function') {\n        // If we are not in a stencil project, we do nothing.\n        // This function is not really exported by @stencil/core.\n        return {};\n    }\n    const elmsToUpdate = new Map();\n    return {\n        dispose: () => elmsToUpdate.clear(),\n        get: (propName) => {\n            const elm = getRenderingRef();\n            if (elm) {\n                appendToMap(elmsToUpdate, propName, elm);\n            }\n        },\n        set: (propName) => {\n            const elements = elmsToUpdate.get(propName);\n            if (elements) {\n                elmsToUpdate.set(propName, elements.filter(forceUpdate));\n            }\n            cleanupElements(elmsToUpdate);\n        },\n        reset: () => {\n            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));\n            cleanupElements(elmsToUpdate);\n        },\n    };\n};\n\nconst unwrap = (val) => (typeof val === 'function' ? val() : val);\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n    const unwrappedState = unwrap(defaultState);\n    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));\n    const handlers = {\n        dispose: [],\n        get: [],\n        set: [],\n        reset: [],\n    };\n    const reset = () => {\n        var _a;\n        // When resetting the state, the default state may be a function - unwrap it to invoke it.\n        // otherwise, the state won't be properly reset\n        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));\n        handlers.reset.forEach((cb) => cb());\n    };\n    const dispose = () => {\n        // Call first dispose as resetting the state would\n        // cause less updates ;)\n        handlers.dispose.forEach((cb) => cb());\n        reset();\n    };\n    const get = (propName) => {\n        handlers.get.forEach((cb) => cb(propName));\n        return states.get(propName);\n    };\n    const set = (propName, value) => {\n        const oldValue = states.get(propName);\n        if (shouldUpdate(value, oldValue, propName)) {\n            states.set(propName, value);\n            handlers.set.forEach((cb) => cb(propName, value, oldValue));\n        }\n    };\n    const state = (typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(unwrappedState, {\n            get(_, propName) {\n                return get(propName);\n            },\n            ownKeys(_) {\n                return Array.from(states.keys());\n            },\n            getOwnPropertyDescriptor() {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            has(_, propName) {\n                return states.has(propName);\n            },\n            set(_, propName, value) {\n                set(propName, value);\n                return true;\n            },\n        }));\n    const on = (eventName, callback) => {\n        handlers[eventName].push(callback);\n        return () => {\n            removeFromArray(handlers[eventName], callback);\n        };\n    };\n    const onChange = (propName, cb) => {\n        const unSet = on('set', (key, newValue) => {\n            if (key === propName) {\n                cb(newValue);\n            }\n        });\n        // We need to unwrap the defaultState because it might be a function.\n        // Otherwise we might not be sending the right reset value.\n        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));\n        return () => {\n            unSet();\n            unReset();\n        };\n    };\n    const use = (...subscriptions) => {\n        const unsubs = subscriptions.reduce((unsubs, subscription) => {\n            if (subscription.set) {\n                unsubs.push(on('set', subscription.set));\n            }\n            if (subscription.get) {\n                unsubs.push(on('get', subscription.get));\n            }\n            if (subscription.reset) {\n                unsubs.push(on('reset', subscription.reset));\n            }\n            if (subscription.dispose) {\n                unsubs.push(on('dispose', subscription.dispose));\n            }\n            return unsubs;\n        }, []);\n        return () => unsubs.forEach((unsub) => unsub());\n    };\n    const forceUpdate = (key) => {\n        const oldValue = states.get(key);\n        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));\n    };\n    return {\n        state,\n        get,\n        set,\n        on,\n        onChange,\n        use,\n        dispose,\n        reset,\n        forceUpdate,\n    };\n};\nconst removeFromArray = (array, item) => {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array[index] = array[array.length - 1];\n        array.length--;\n    }\n};\n\nconst createStore = (defaultState, shouldUpdate) => {\n    const map = createObservableMap(defaultState, shouldUpdate);\n    map.use(stencilSubscription());\n    return map;\n};\n\nexport { createObservableMap, createStore };\n"],
  "mappings": "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",
  "names": ["unsubs", "forceUpdate"]
}
